\section{Introduction}\label{sec:introduction}

In today's fast-moving software world, no large software project is developed by
one single person. Team coordination becomes a challenging factor in software
development, as success rates drop with increasing team sizes
\cite{ambler:2010}. Another central pillar of modern software development is
testing. While proper software testing clearly boosts software quality, it is
incredibly expensive \cite{dustin:1999}.\\

Continuous Integration is an approach to addresses these problems by
\begin{enumerate}[label=(\alph*)]
    \item Applying small incremental changes over time to a central source code
       repository
    \item Employing an automated testing strategy
\end{enumerate}

and strives to improve team efficiency all together.

\subsection{History}\label{sec:history}

Before Continuous Integration, developers worked on their own separate copies of
the project for (possibly) long amounts of time. The integration phase of
software development was scheduled at the end of feature implementation. The
problem here is, that not all developers worked on the same setup. They use
different tools or versions on different machines. This would cause various
instances of "works-for-me"-bugs, issues appeared for some, but not for all
involved individuals.\\

To prevent this from happening (at least for build-time-errors), often a
designated build-machine was employed - a server that developers pushed their
commits to that would automatically build the whole project. Commits would only
be considered valid, if the build-server was able to build them. Various tools
were developed to run on these servers (see \ref{sec:tooling-self-hosted}) and gradually,
these server's capabilities were expanded beyond just building
\cite{zilberfeld:2013}.\\

When Continuous Integration first became popular, it was tightly coupled to many
concepts practiced in Extreme Programming. In this software development
methodology, (typically small) development teams use various coding-focused
techniques in order to develop software faster.


